const fs = require('fs')
const moment = require('moment')
const request = require('request')
const SHA256 = require('crypto-js/sha256')

const [memberId, keyId, keyVal] = fs.readFileSync('.easy-sinopac.private').toString().split(/[:\n]/)

const accountRead = account => getOrders() // {{{
  .then(orders => {
    const accounts = {}
    for (let o of orders) {
      const order = parseOrder(o)
      if ('P' === order.extra) continue // un-confirmed pay
      if (order.amount < 0) return reject('minus amount') //! more advanced error checking
      if (!accounts[order.src]) accounts[order.src] = { balance: 0, id: order.src }
      if (!accounts[order.dst]) accounts[order.dst] = { balance: 0, id: order.dst }
      if (accounts[order.src].balance - order.amount < 0 && 'mbibank' !== order.src) continue // failed transfer/pay
      accounts[order.src].balance -= order.amount
      accounts[order.dst].balance += order.amount
    }
    return accounts[account]
      ? Promise.resolve(accounts[account])
      : Promise.reject(new Error(`account ${account} does not exist`))
  }) // }}}

const getOrders = (force = '') => new Promise((resolve, reject) => { // {{{
  if ('local' === force) {
    fs.readFile('.easy-sinopac.orders', (erro, data) => {
      if (erro) resolve([])
      resolve(data.toString() ? JSON.parse(data.toString()) : [])
    })
    return
  }

  ('sinopac' === force
    ? Promise.resolve([])
    : getOrders('local')
  ).then(orders => {
    const next = (iOrder) => {
      if ('sinopac' !== force) {
        while (parseOrder(orders[iOrder])) {
          //info('order existed in local', iOrder+1)
          iOrder++
        }
      }
      return sinopacRead(iOrder+1).then(resp => {
        //if (!parseOrder(resp)) return resolve(orders) // un-comment to fill missing order numbers
        if (!parseOrder(resp) && iOrder >= orders.length) return resolve(orders)
        orders[iOrder] = resp
        fs.writeFile('.easy-sinopac.orders', JSON.stringify(orders, null, 2), erro => {
          if (erro) return reject(erro)
          //info('order existed in sinopac', iOrder+1)
          next(++iOrder)
        })
      }, () => resolve(orders))
    }
    next(0)
  })
}) // }}}

function info(title, content) {
  console.info('\x1b[32m%s \x1b[0m%s', title, content)
}

const parseOrder = order => { // {{{
  if (!order) return null
  const mat = order.toString().replace(/[\r\n]+/g, '').match(/<OrderNO>(.*?)<.*<Amount>(.*?)<.*<Param1>(.*?):(.*?):(.*?)</)
  if (!mat) return null
  return {
    orderNo: mat[1],
    amount: parseInt(mat[2]) / 100,
    src: mat[3],
    dst: mat[4],
    extra: mat[5],
  }
} // }}}

const parseResp = (response) => {
  const mat = response.replace(/[ \r\n]*/g, '').match(/<OrderNO>(.*?)<.*<Status>(.*?)<.*<Description>(.*?)<.*<Param1>(.*?):(.*?):(.*?)</)
  return {
    orderNo: mat[1],
    status: mat[2],
    description: mat[3],
    src: mat[4],
    dst: mat[5],
    extra: mat[6],
  }
}

const promiseOrCallback = (promise, callback) => { // {{{
  if ('function' === typeof callback)
    return promise.then(resp => callback(null, resp)
    , erro => callback(erro))
  return promise
} // }}}

const sinopacCreate = (src, dst, amount, extra) => takeOrderNo() // {{{
  .then(orderNo => {
    // info('creating order', orderNo)
    return sinopacRequest(
      'https://sandbox.sinopac.com/WebAPI/Service.svc/CreateATMOrIBonTrans',
      `<ATMOrIBonClientRequest xmlns="http://schemas.datacontract.org/2004/07/SinoPacWebAPI.Contract">
        <ShopNO>${memberId}</ShopNO>
        <KeyNum>${keyId}</KeyNum>
        <OrderNO>${orderNo}</OrderNO>
        <Amount>${amount}</Amount>
        <CurrencyID>NTD</CurrencyID>
        <ExpireDate>${moment().add(20, 'day').format('YYYYMMDD')}</ExpireDate>
        <PayType>A</PayType>
        <PrdtName>MBILAB</PrdtName>
        <Memo></Memo>
        <PayerName></PayerName>
        <PayerMobile></PayerMobile>
        <PayerAddress></PayerAddress>
        <PayerEmail></PayerEmail>
        <ReceiverName></ReceiverName>
        <ReceiverMobile></ReceiverMobile>
        <ReceiverAddress></ReceiverAddress>
        <ReceiverEmail></ReceiverEmail>
        <Param1>${src}:${dst}:${extra}</Param1>
        <Param2></Param2>
        <Param3></Param3>
      </ATMOrIBonClientRequest>`
    )
  }).then(resp => {
    resp = parseResp(resp) //! if the same as sinopacRead, do it inside sinopacRequest
    if ('S00000' !== resp.description) 
      return Promise.reject(new Error('Status is not S'))
    else {
      if ('mbibank' === resp.src) {
        delete resp.orderNo
        delete resp.status
        delete resp.description
        delete resp.src
        delete resp.extra
      } else if (resp.extra.match(new RegExp(`P:.*`))) {
        delete resp.orderNo
        delete resp.status
        delete resp.description
        delete resp.extra
      } else {
        delete resp.status
        delete resp.description
        delete resp.extra
      }
      return Promise.resolve(resp)
    }
  }) // }}}

const sinopacRead = orderNo => { // {{{
  // info('reading order', orderNo)
  return sinopacRequest(
    'https://sandbox.sinopac.com/WebAPI/Service.svc/QueryTradeStatus',
    `<QueryTradeStatusRequest xmlns="http://schemas.datacontract.org/2004/07/SinoPacWebAPI.Contract.QueryTradeStatus">
      <ShopNO>${memberId}</ShopNO>
      <KeyNum>${keyId}</KeyNum>
      <OrderNO>${orderNo}</OrderNO>
      <PayType></PayType>
      <OrderDateS></OrderDateS>
      <OrderTimeS></OrderTimeS>
      <OrderDateE></OrderDateE>
      <OrderTimeE></OrderTimeE>
      <PayFlag>A</PayFlag>
      <PrdtNameFlag>Y</PrdtNameFlag>
      <MemoFlag>Y</MemoFlag>
      <PayerNameFlag>N</PayerNameFlag>
      <PayerMobileFlag>N</PayerMobileFlag>
      <PayerAddressFlag>N</PayerAddressFlag>
      <PayerEmailFlag>N</PayerEmailFlag>
      <ReceiverNameFlag>N</ReceiverNameFlag>
      <ReceiverMobileFlag>N</ReceiverMobileFlag>
      <ReceiverAddressFlag>N</ReceiverAddressFlag>
      <ReceiverEmailFlag>N</ReceiverEmailFlag>
      <ParamFlag1>Y</ParamFlag1>
      <ParamFlag2>Y</ParamFlag2>
      <ParamFlag3>Y</ParamFlag3>
      <StagingFlag>N</StagingFlag>
      <DividendFlag>N</DividendFlag>
    </QueryTradeStatusRequest>`)
  } // }}}

const sinopacRequest = (url, msg) => new Promise((resolve, reject) => { // {{{
  //! requestPromise?
  request.post({
    encoding: 'utf8',
    method: 'POST',
    rejectUnauthorized: false,
    url: url,
  }, (erro, resp, body) => {
    if (erro) return reject(erro)

    const trimmedMsg = msg.replace(/[ \r\n]*/g, '')
    const [origin, realm, nonce, qop] = resp.headers['www-authenticate'].match(/realm="(.*?)", nonce="(.*?)", qop="(.*?)"/)
    const cnonce = Math.floor(Math.random() * 9876599 + 123400)
    const hash1 = SHA256(`${memberId}:${realm}:${keyVal}`)
    const hash2 = SHA256(`POST:${url}`)
    const verifycode = SHA256(`${hash1}:${nonce}:${cnonce}:${qop}:${trimmedMsg}:${hash2}`)
    const digestHeader = `Digest realm="${realm}", nonce="${nonce}", uri="${url}", verifycode="${verifycode}", qop="${qop}", cnonce="${cnonce}"`

    request.post({
      body: msg,
      encoding: 'utf8',
      headers: {
        'Content-type': 'text/xml',
        'Authorization': digestHeader
      },
      rejectUnauthorized: false,
      url: url,
    }, (erro, resp) => {
      if (erro) return reject(erro)
      resolve(resp.body)
    })
  })
}) // }}}

const takeOrderNo = () => new Promise((resolve, reject) => { // {{{
  getOrders().then(orders => {
    orders.push('taken')
    fs.writeFile('.easy-sinopac.orders', JSON.stringify(orders, null, 2), erro => {
      if (erro) return reject(erro)
      resolve(orders.length)
    })
  })
}) // }}}

module.exports = {

  account: {

    create: (account, amount, callback) => promiseOrCallback(
      sinopacCreate('mbibank', account, amount*100, 'T'),
      callback
    ),

    read: (account, callback) => promiseOrCallback(
      accountRead(account),
      callback
    ),

  },

  pay: {

    confirm: (pay, callback) => promiseOrCallback(
      getOrders().then(orders => {
        for (let o of orders) {
          if (!o.toString().match(new RegExp(`<OrderNO>${pay}<`))) continue
          const order = parseOrder(o)
          return sinopacCreate(order.src, order.dst, order.amount, `P:${pay}`, callback)
        }
      }),
      callback
    ),

    create: (source, destination, amount, callback) => promiseOrCallback(
      sinopacCreate(source, destination, amount*100, 'P'),
      callback
    ),

    read: (id, callback) => promiseOrCallback(
      getOrders().then(orders => {
        let order
        for (let o of orders) {
          if (o.replace(/[\r\n]+/g, '').match(new RegExp(`<OrderNO>${id}<.*<Param1>.*?:.*?:P<`)))
            order = parseOrder(o)
          if (o.match(new RegExp(`:P:${id}<`)))
            order.confirmed = true
        }
        if(order) {
          delete order.extra
          return Promise.resolve(order)
        } else {
          return Promise.reject(new Error(`pay ${id} does not exist`))
        }
      }),
      callback
    ),

  },

  transfer: {

    create: (source, destination, amount, callback) => promiseOrCallback(
      sinopacCreate(source, destination, amount*100, 'T'),
      callback
    ),

    read: (id, callback) => promiseOrCallback(
      getOrders().then(orders => {
        for (let o of orders) {
          if (o.replace(/[\r\n]+/g, '').match(new RegExp(`<OrderNO>${id}<.*<Param1>.*?:.*?:T<`)))
            var resp = parseOrder(o)
            delete resp.extra
            return Promise.resolve(resp)
        }
        return Promise.reject(new Error(`transfer ${id} does not exist`))
      }),
      callback
    ),

  }
}

// vi:et:ft=javascript
